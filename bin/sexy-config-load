#!/bin/sh
# 
# 2009      Nico Schottelius (nico-sexy at schottelius.org)
# 
# This file is part of sexy.
#
# sexy is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# sexy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with sexy. If not, see <http://www.gnu.org/licenses/>.
#
#
# Load the configuration - this script should be sourced
#

################################################################################
# standard vars stolen from cconf, renamed for sexy
__sexy_pwd="$(pwd -P)"
__sexy_mydir="${0%/*}"; __sexy_abs_mydir="$(cd "$__sexy_mydir" && pwd -P)"
__sexy_myname=${0##*/}; __sexy_abs_myname="$__sexy_abs_mydir/$__sexy_myname"


# where our database / components can be found
sexy_db="${sexy_db:-$HOME/.sexy}"
sexy_db_abs="$(cd "${sexy_db}" && pwd -P)"
sexy_default_config="${sexy_db_abs}/${sexy_config_path}"

#
# Determine the current configuration directory
# A very mysterious, powerfull expression:
# Use the sexy db base + config + # Remove the database path, add the sexy db base + config +  
#
sexy_my_config="${sexy_db_abs}/${__sexy_abs_mydir##$sexy_db_abs}/.config"
sexy_my_tmp="${sexy_db_abs}/tmp${__sexy_abs_mydir##$sexy_db_abs}"


sexy_objects="backends hosts networks"

for sexy_object in $sexy_objects; do
   # This is the same as
   # : ${sexy_path_backends:="backends"}
   # just for variable names
   eval \: \${sexy_path_${sexy_object}:="$sexy_object"}

   #
   # Create full path in db, like
   # sexy_db_backends="${sexy_db}/${sexy_path_networks}"
   #
   eval sexy_db_${sexy_object}="\"${sexy_db}/\${sexy_path_${sexy_object}}\""

   #
   # The path to the configuration (if available) for an object.
   #
   eval sexy_db_config_${sexy_object}="\"${sexy_db}/config/\${sexy_path_${sexy_object}}\""

   # Debug output
   # eval echo "\${sexy_db_${sexy_object}}"
done
sexy_object=""

# What cares about what
sexy_object_types="${sexy_path_hosts} ${sexy_path_networks}"
sexy_runner_known="${sexy_path_networks}"

################################################################################
# Convert fqdn to hostname
sexy_fqdn_to_hostname()
{
   sexy_host="$1"; shift
}

# Return if a host exists in a network
sexy_host_exists()
{
   sexy_network="$1"; shift
   sexy_host="$1"; shift

   if [ -d "$(sexy_object_path "${sexy_path_networks}" "${sexy_network}")/hosts/${sexy_host}" ]; then
      return 0
   else
      return 1
   fi
}

########## TYPES
# Return type path
sexy_type_path()
{
   sexy_type="$1"; shift

   eval echo \${sexy_db_${sexy_type}}
}


# Retrieve configuration for a type FIXME
sexy_type_attribute_get()
{
   sexy_type="$1"; shift
   sexy_attribute="$1"; shift

   cat "$(sexy_type_path "${sexy_type}")/.config/${sexy_attribute}"
}

# Retrieve configuration path for a type
sexy_type_config_path()
{
   sexy_type="$1"; shift
   sexy_config="$1"; shift

   echo "$(sexy_type_path "${sexy_type}")/.config/${sexy_config}"
}

# Retrieve configuration for a type
sexy_type_config_get()
{
   sexy_type="$1"; shift
   sexy_config="$1"; shift

   cat "$(sexy_type_config_path "${sexy_type}" "${sexy_config}")"
}

# Retrieve configuration for a type, failing is ok
sexy_type_config_failok_get()
{
   sexy_type="$1"; shift
   sexy_config="$1"; shift

   sexy_type_config_get "${sexy_type}" "${sexy_config}" 2>/dev/null || true
}


########## OBJECTS
# Retrieve configuration for an object
sexy_object_config_failok_get()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift

   sexy_object_config_get "${sexy_type}" "${sexy_object}" "${sexy_config}" 2>/dev/null || true
}

sexy_object_config_get()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift

   cat "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "${sexy_config}")"
}

# Configure configuration for an object
sexy_object_config_set()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift
   sexy_value="$1"; shift

   set -x
   mkdir -p "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "")"
   echo "${sexy_value}" > "$(sexy_object_config_path "${sexy_type}" "${sexy_object}" "${sexy_config}")"
   set +x
}

# Retrieve configuration path for an object
sexy_object_config_path()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_config="$1"; shift

   echo "$(sexy_type_path "${sexy_type}")/${sexy_object}/.config/${sexy_config}"
}

# Return attribute: object specific
sexy_object_attribute_get()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_attribute="$1"; shift

   cat "$(sexy_object_attribute_path "${type}" "${object}" "${attribute}")"
}


# Return object path
sexy_object_attribute_path()
{
   sexy_type="$1"; shift
   sexy_object="$1"; shift
   sexy_attribute="$1"; shift

   sexy_object_attribute_path="$(sexy_object_path "$sexy_type" "$sexy_object")/${sexy_attribute}"
   echo "${sexy_object_attribute_path}"
}

# Return if object exists or not
sexy_object_attribute_exists()
{
   type="$1"; shift
   object="$1"; shift
   attribute="$1"; shift

   if [ -d "$(sexy_object_attribute_path "${type}" "${object}" "${attribute}")" ]; then
      return 0
   else
      return 1
   fi
}

# Return object path
sexy_object_path()
{
   type="$1"; shift
   object="$1"; shift

   echo "$(sexy_type_path "${type}")/${object}"
}

# Return if object exists or not
sexy_object_exists()
{
   type="$1"; shift
   object="$1"; shift

   if [ -d "$(sexy_object_path "${type}" "${object}")" ]; then
      return 0
   else
      return 1
   fi
}

# Return one byte of an ipv4 address
sexy_ipv4_get_byte()
{
   sexy_ipv4_addr="$1"; shift
   sexy_byte_num="$1"; shift

   echo "$sexy_ipv4_addr" | cut -d. "-f${sexy_byte_num}"
}

# Increment given ipv4 address by one
sexy_ipv4_addr_increment()
{
   sexy_ipv4_addr="$1"; shift

   sexy_i="4"
   sexy_ipv4_added="0"
   sexy_ipv4_addr_new=""

   while [ $sexy_i -ge 1 ]; do
      sexy_ipv4_byte=$(sexy_ipv4_get_byte $sexy_ipv4_addr ${sexy_i})

      if [ $sexy_ipv4_added -eq 0 ]; then
         if [ $((${sexy_ipv4_byte} + 1)) -gt 255 ]; then
            sexy_ipv4_byte="0"
         else
            sexy_ipv4_byte=$((${sexy_ipv4_byte} + 1))
            sexy_ipv4_added="1"
         fi
      fi

      sexy_ipv4_addr_new="${sexy_ipv4_byte}${sexy_ipv4_addr_new}"
      [ $sexy_i -gt 1 ] && sexy_ipv4_addr_new=".${sexy_ipv4_addr_new}"

      sexy_i=$(($sexy_i - 1))
   done

   echo $sexy_ipv4_addr_new
}

# Convert netmask from bitmask to decimal
sexy_network_decimal_netmask()
{
   sexy_mask_rest="$1"; shift
   sexy_decimal_mask="";
   sexy_i="0"

   while [ $sexy_i -lt 4 ]; do
      if [ "$(($sexy_mask_rest / 8))" -gt 1 ]; then
         byte=255
         sexy_mask_rest="$(($sexy_mask_rest-8))"
      else
         byte=1
         while [ $sexy_mask_rest -gt 0 -a $byte -lt 256 ]; do
            byte=$(($byte *2))
            sexy_mask_rest=$(($sexy_mask_rest-1))
         done
         byte=$(($byte-1))
      fi  

      sexy_decimal_mask="${sexy_decimal_mask}${byte}"

      sexy_i=$(($sexy_i + 1))

      [ $sexy_i -lt 4 ] && sexy_decimal_mask="${sexy_decimal_mask}."
   done

   echo $sexy_decimal_mask
}

# Calculate broadcast for subnet
sexy_network_decimal_broadcast()
{
   sexy_network="$1"; shift
   sexy_mask_rest="$1"; shift
   sexy_decimal_broadcast="";
   sexy_i="0"

   while [ "${sexy_i}" -lt 4 ]; do
      if [ "$(($sexy_mask_rest / 8))" -gt 1 ]; then
         sexy_netmask_byte=255
         sexy_mask_rest="$(($sexy_mask_rest-8))"
      else
         sexy_netmask_byte=1
         while [ $sexy_mask_rest -gt 0 -a $sexy_netmask_byte -lt 256 ]; do
            sexy_netmask_byte=$(($sexy_netmask_byte *2))
            sexy_mask_rest=$(($sexy_mask_rest-1))
         done
         sexy_netmask_byte=$(($sexy_netmask_byte-1))
      fi  
 
      sexy_current_field="$(sexy_ipv4_get_byte $sexy_network $(($sexy_i+1)))"
      sexy_current_broadcast="$(($sexy_current_field | ($sexy_netmask_byte ^ 255)))"

      sexy_decimal_broadcast="${sexy_decimal_broadcast}${sexy_current_broadcast}"

      sexy_i=$(($sexy_i + 1))

      [ $sexy_i -lt 4 ] && sexy_decimal_broadcast="${sexy_decimal_broadcast}."
   done

   echo $sexy_decimal_broadcast
}

# Share a temp file (within a backend for instance)
sexy_shared_temp()
{
   set -e
   sexy_temp_name="tempfile"

   [ "$1" ]; sexy_temp_name="${sexy_temp_name}-$1"
   sexy_tempfile="${sexy_my_tmp}/${sexy_temp_name}"
   mkdir -p "${sexy_my_tmp}"
   touch "${sexy_tempfile}"
   echo "${sexy_tempfile}"
}

# the secure variant
sexy_mktemp()
{
   set -e
   mkdir -p "${sexy_my_tmp}"
   mktemp "${sexy_my_tmp}/tempfile.XXXXXXXXXXXXXXX"
}

# Write message, prefixed by scriptname
sexy_msg()
{
   echo "${__sexy_myname}: $@"
}

sexy_errormsg()
{
   sexy_msg "$@"
   exit 1
}

# argument(s) should not be empty
sexy_notempty()
{
   errormsg="$1"; shift

   while [ "$#" -gt 0 ]; do
      if [ "$1" ]; then
         shift
      else
         sexy_errormsg "$errormsg"
      fi
   done
}

# read a file with error handling
sexy_file_read()
{
   sexy_file="$1"; shift

   cat "${sexy_file}" || sexy_errormsg "Cannot read file ${sexy_file}"

}

# Require some command line parameters
sexy_args()
{

   count=0
   arglist=""

   # get argument list
   while [ "$1" != "--" ]; do
      eval arg_$count=\"$1\"
      arglist="$arglist $1"
      shift
      count=$(($count+1))
   done
   shift; # skip --

   if [ "$#" -ne "$count" ]; then
      sexy_errormsg ${arglist}
   fi

   # assign values
   count=0
   while [ "$#" -gt 0 ]; do
      eval export \$arg_$count=\"$1\"
      shift
      count=$(($count+1))
   done
}
